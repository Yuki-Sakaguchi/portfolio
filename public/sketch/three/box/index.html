<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>three - box.</title>
    <style>
      body {
        width: 100vw;
        height: 100vh;
        margin: 0;
        overflow: hidden;
      }
    </style>
  </head>
  <body>
    <div id="WebGL-output"></div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/107/three.min.js" integrity="sha256-321vzZNUH74ANBmvgqtE7e0gtGUjvWYaGMqu63RMcmg=" crossorigin="anonymous"></script>
    <script>

      let movePoint = 10;
      let speed = 400;
      let easingIn = TWEEN.Easing.Quartic.InOut

      document.addEventListener('click', function () {
        if (speed == 50) {
          speed = 600;
        }
        speed -= 50;
      })

      class Cube {
        constructor (color) {
          // ３次元の立方体
          const cubeGeometry = new THREE.BoxGeometry(2, 2, 2)
          const cubeMaterial = new THREE.MeshLambertMaterial({
            color: color,
            // wireframe: true, // 線だけで描画
          })
          this.mesh = new THREE.Mesh(cubeGeometry, cubeMaterial)
          this.mesh.position.x = 0
          this.mesh.position.y = 2
          this.mesh.position.z = 0
          this.mesh.castShadow = true
        }

        moveRight () {
          var _this = this
          var scaleTween = new TWEEN.Tween({
            scale: 1,
          })
          .to({
            scale: 1 + (movePoint/6),
          }, speed)
          .easing(easingIn)
          .onUpdate(function() {
            _this.mesh.scale.x = this.scale;
          })
          .onComplete(function () {
            new TWEEN.Tween({
              scale: 1 + (movePoint/6),
            })
            .to({
              scale: 1,
            }, speed)
            .easing(easingIn)
            .onUpdate(function() {
              _this.mesh.scale.x = this.scale;
            }).start();
          })
          .start();

          var moveTween = new TWEEN.Tween({
            position: 0,
          })
          .to({
            position: (movePoint/2),
          }, speed)
          .easing(easingIn)
          .onUpdate(function() {
            _this.mesh.position.x = this.position;
          })
          .onComplete(function () {
            new TWEEN.Tween({
              position: (movePoint/2),
            })
            .to({
              position: movePoint,
            }, speed)
            .easing(easingIn)
            .onUpdate(function() {
              _this.mesh.position.x = this.position;
            }).start();
          })
          .start();
        }

        moveBottom () {
          var _this = this
          var scaleTween = new TWEEN.Tween({
            scale: 1,
          })
          .to({
            scale: 1 + (movePoint/6),
          }, speed)
          .easing(easingIn)
          .onUpdate(function() {
            _this.mesh.scale.z = this.scale;
          })
          .onComplete(function () {
            new TWEEN.Tween({
              scale: 1 + (movePoint/6),
            })
            .to({
              scale: 1,
            }, speed)
            .easing(easingIn)
            .onUpdate(function() {
              _this.mesh.scale.z = this.scale;
            }).start();
          })
          .start();

          var moveTween = new TWEEN.Tween({
            position: 0,
          })
          .to({
            position: (movePoint/2),
          }, speed)
          .easing(easingIn)
          .onUpdate(function() {
            _this.mesh.position.z = this.position;
          })
          .onComplete(function () {
            new TWEEN.Tween({
              position: (movePoint/2),
            })
            .to({
              position: movePoint,
            }, speed)
            .easing(easingIn)
            .onUpdate(function() {
              _this.mesh.position.z = this.position;
            }).start();
          })
          .start();
        }

        moveLeft () {
          var _this = this
          var scaleTween = new TWEEN.Tween({
            scale: 1,
          })
          .to({
            scale: 1 + (movePoint/6),
          }, speed)
          .easing(easingIn)
          .onUpdate(function() {
            _this.mesh.scale.x = this.scale;
          })
          .onComplete(function () {
            new TWEEN.Tween({
              scale: 1 + (movePoint/6),
            })
            .to({
              scale: 1,
            }, speed)
            .easing(easingIn)
            .onUpdate(function() {
              _this.mesh.scale.x = this.scale;
            }).start();
          })
          .start();

          var moveTween = new TWEEN.Tween({
            position: movePoint,
          })
          .to({
            position: movePoint - (movePoint/2),
          }, speed)
          .easing(easingIn)
          .onUpdate(function() {
            _this.mesh.position.x = this.position;
          })
          .onComplete(function () {
            new TWEEN.Tween({
              position: (movePoint/2),
            })
            .to({
              position: 0,
            }, speed)
            .easing(easingIn)
            .onUpdate(function() {
              _this.mesh.position.x = this.position;
            }).start();
          })
          .start();
        }

        moveTop () {
          var _this = this
          var scaleTween = new TWEEN.Tween({
            scale: 1,
          })
          .to({
            scale: 1 + (movePoint/6),
          }, speed)
          .easing(easingIn)
          .onUpdate(function() {
            _this.mesh.scale.z = this.scale;
          })
          .onComplete(function () {
            new TWEEN.Tween({
              scale: 1 + (movePoint/6),
            })
            .to({
              scale: 1,
            }, speed)
            .easing(easingIn)
            .onUpdate(function() {
              _this.mesh.scale.z = this.scale;
            }).start();
          })
          .start();

          var moveTween = new TWEEN.Tween({
            position: movePoint,
          })
          .to({
            position: movePoint - (movePoint/2),
          }, speed)
          .easing(easingIn)
          .onUpdate(function() {
            _this.mesh.position.z = this.position;
          })
          .onComplete(function () {
            new TWEEN.Tween({
              position: movePoint - (movePoint/2),
            })
            .to({
              position: 0,
            }, speed)
            .easing(easingIn)
            .onUpdate(function() {
              _this.mesh.position.z = this.position;
            }).start();
          })
          .start();
        }

        play () {
          switch (this.index) {
            case 1:
              this.moveRight();
              break;
            case 2:
              this.moveBottom();
              break;
            case 3:
              this.moveLeft();
              break;
            case 4:
              this.moveTop();
              break;
          }
          var _this = this;
          setTimeout(function () {
            _this.index++;
            if (_this.index > 4) {
              _this.index = 1;
            }
            _this.play();
          }, speed * 2);
        }
      }

      // アニメーションで使う変数
      let step = 0

      // シーン
      const scene = new THREE.Scene()

      // カメラ（アイソメトリック）
      let aspect = window.innerWidth / window.innerHeight;
      let d = 20;
      let camera = new THREE.OrthographicCamera(-d * aspect, d * aspect, d, -d, 1, 1000);
      camera.position.set(20, 20, 20);
      camera.lookAt(scene.position);

      // スポットライト
      const spotLight = new THREE.SpotLight(0xffffff)
      spotLight.position.set(60, 90, 70)
      // spotLight.castShadow = true // 影を描画する
      scene.add(spotLight)

      // レンダラー
      const renderer = new THREE.WebGLRenderer({ antialias: true })
      renderer.setClearColor(new THREE.Color(0xffffff)) // 背景色を設定
      renderer.setSize(window.innerWidth, window.innerHeight) // 描画するシーンの大きさ設定
      renderer.shadowMap.enabled = true // 影を描画する

      // x, y, z軸のデバッグ用オブジェクト
      // const axes = new THREE.AxesHelper(20)
      // scene.add(axes)

      const redCube = new Cube(0xff4444);
      redCube.mesh.position.z = 0;
      redCube.mesh.position.x = 0;
      redCube.index = 1;
      scene.add(redCube.mesh)
      redCube.play();

      const blueCube = new Cube(0x4444ff);
      blueCube.mesh.position.z = 0;
      blueCube.mesh.position.x = movePoint;
      blueCube.index = 2;
      scene.add(blueCube.mesh)
      blueCube.play();

      const greenCube = new Cube(0x44ff44);
      greenCube.mesh.position.z = movePoint;
      greenCube.mesh.position.x = movePoint;
      greenCube.index = 3;
      scene.add(greenCube.mesh)
      greenCube.play();

      const yellowCube = new Cube(0xffff44);
      yellowCube.mesh.position.z = movePoint;
      yellowCube.mesh.position.x = 0;
      yellowCube.index = 4;
      scene.add(yellowCube.mesh)
      yellowCube.play();


      /**
       * 描画する関数
       */
      function rendererScene () {
        requestAnimationFrame(rendererScene) // 再帰的にアニメーション実行
        renderer.render(scene, camera) // 描画
        TWEEN.update()
      }

      /**
       * リサイズ時の表示変更処理
       */
      function onResize () {
        // サイズを取得
        const width = window.innerWidth;
        const height = window.innerHeight;

        // レンダラーのサイズを調整する
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(width, height);

        // カメラのアスペクト比を正す
        aspect = window.innerWidth / window.innerHeight;
        camera.left = -aspect * d;
        camera.right = aspect * d ;
        camera.top = d;
        camera.bottom = -d;
        camera.updateProjectionMatrix();
      }

      // DOMに追加し、アニメーションを開始
      document.getElementById('WebGL-output').appendChild(renderer.domElement)
      window.addEventListener('resize', onResize)
      rendererScene()
    </script>
    <script>
      document.addEventListener('touchmove', function(e) {
        e.preventDefault()
      }, {passive: false})
    </script>
  </body>
</html>